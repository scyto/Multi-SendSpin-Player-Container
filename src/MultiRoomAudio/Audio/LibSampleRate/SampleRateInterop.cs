using System.Runtime.InteropServices;

namespace MultiRoomAudio.Audio.LibSampleRate;

/// <summary>
/// P/Invoke bindings for libsamplerate (Secret Rabbit Code).
/// libsamplerate is a high-quality sample rate converter library.
/// See: http://libsndfile.github.io/libsamplerate/api_full.html
/// </summary>
internal static class SampleRateInterop
{
    // Library name varies by platform
    // On Linux: libsamplerate.so.0
    // On macOS: libsamplerate.dylib (if installed via Homebrew)
    private const string LibName = "libsamplerate.so.0";

    /// <summary>
    /// Converter type constants (quality vs CPU trade-off).
    /// </summary>
    public static class ConverterType
    {
        /// <summary>
        /// Best quality, highest CPU. Band limited sinc interpolator, best quality, 97dB SNR, 96% BW.
        /// </summary>
        public const int SincBestQuality = 0;

        /// <summary>
        /// Good balance of quality and CPU. Band limited sinc interpolator, medium quality, 97dB SNR, 90% BW.
        /// </summary>
        public const int SincMediumQuality = 1;

        /// <summary>
        /// Lower quality, faster. Band limited sinc interpolator, fastest, 97dB SNR, 80% BW.
        /// </summary>
        public const int SincFastest = 2;

        /// <summary>
        /// Lowest quality, very fast. Zero order hold converter, very fast but poor quality.
        /// </summary>
        public const int ZeroOrderHold = 3;

        /// <summary>
        /// Linear interpolation. Fast, low quality.
        /// </summary>
        public const int Linear = 4;
    }

    /// <summary>
    /// Error codes returned by libsamplerate functions.
    /// </summary>
    public static class ErrorCode
    {
        public const int NoError = 0;
        public const int MallocFailed = 1;
        public const int BadState = 2;
        public const int BadData = 3;
        public const int BadDataPtr = 4;
        public const int NoPrivate = 5;
        public const int BadSrcRatio = 6;
        public const int BadProcPtr = 7;
        public const int ShiftBits = 8;
        public const int FilterLen = 9;
        public const int BadConverter = 10;
        public const int BadChannelCount = 11;
        public const int SincBadBufferLen = 12;
        public const int SizeIncompatibility = 13;
        public const int BadPrivPtr = 14;
        public const int BadSincState = 15;
        public const int DataOverlap = 16;
        public const int BadCallback = 17;
        public const int BadMode = 18;
        public const int NullCallback = 19;
        public const int NoVariableRatio = 20;
        public const int SincPrepareDataBadLen = 21;
        public const int MaxError = 22;
    }

    /// <summary>
    /// Data structure passed to src_process for resampling.
    /// </summary>
    /// <remarks>
    /// libsamplerate uses C 'long' for frame counts. On 64-bit Linux (LP64 data model),
    /// C 'long' is 8 bytes. We use 'nint' (native int) to match the platform size.
    /// </remarks>
    [StructLayout(LayoutKind.Sequential)]
    public struct SrcData
    {
        /// <summary>
        /// Pointer to input float array (interleaved for multi-channel).
        /// </summary>
        public IntPtr DataIn;

        /// <summary>
        /// Pointer to output float array (interleaved for multi-channel).
        /// </summary>
        public IntPtr DataOut;

        /// <summary>
        /// Number of input frames available (frames = samples / channels).
        /// Uses nint to match C 'long' on LP64 systems (8 bytes on 64-bit Linux).
        /// </summary>
        public nint InputFrames;

        /// <summary>
        /// Number of output frames that can be written.
        /// Uses nint to match C 'long' on LP64 systems (8 bytes on 64-bit Linux).
        /// </summary>
        public nint OutputFrames;

        /// <summary>
        /// [Output] Number of input frames consumed by src_process.
        /// Uses nint to match C 'long' on LP64 systems (8 bytes on 64-bit Linux).
        /// </summary>
        public nint InputFramesUsed;

        /// <summary>
        /// [Output] Number of output frames generated by src_process.
        /// Uses nint to match C 'long' on LP64 systems (8 bytes on 64-bit Linux).
        /// </summary>
        public nint OutputFramesGen;

        /// <summary>
        /// Set to non-zero when no more input will be provided (for flushing).
        /// This is C 'int' (4 bytes on all platforms).
        /// </summary>
        public int EndOfInput;

        /// <summary>
        /// Conversion ratio: output_sample_rate / input_sample_rate.
        /// For variable-rate conversion, this can change between calls.
        /// libsamplerate smoothly interpolates between the previous and current ratio.
        /// </summary>
        public double SrcRatio;
    }

    /// <summary>
    /// Creates a new sample rate converter state.
    /// </summary>
    /// <param name="converterType">One of ConverterType constants.</param>
    /// <param name="channels">Number of audio channels.</param>
    /// <param name="error">Receives error code if function fails.</param>
    /// <returns>Opaque state pointer, or IntPtr.Zero on failure.</returns>
    [DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "src_new")]
    public static extern IntPtr New(int converterType, int channels, out int error);

    /// <summary>
    /// Destroys a sample rate converter state and frees resources.
    /// </summary>
    /// <param name="state">State pointer from src_new.</param>
    /// <returns>Always returns IntPtr.Zero (for chaining: state = src_delete(state)).</returns>
    [DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "src_delete")]
    public static extern IntPtr Delete(IntPtr state);

    /// <summary>
    /// Processes audio data through the sample rate converter.
    /// For variable-rate conversion, the ratio can change between calls.
    /// The library smoothly interpolates between the old and new ratio.
    /// </summary>
    /// <param name="state">State pointer from src_new.</param>
    /// <param name="data">Input/output data structure.</param>
    /// <returns>0 on success, or error code.</returns>
    [DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "src_process")]
    public static extern int Process(IntPtr state, ref SrcData data);

    /// <summary>
    /// Resets the converter state (clears internal buffers).
    /// Call this when starting a new audio stream.
    /// </summary>
    /// <param name="state">State pointer from src_new.</param>
    /// <returns>0 on success, or error code.</returns>
    [DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "src_reset")]
    public static extern int Reset(IntPtr state);

    /// <summary>
    /// Sets a new conversion ratio for variable-rate conversion.
    /// This must be called BEFORE src_process if changing the ratio mid-stream,
    /// but it's usually easier to just set SrcData.SrcRatio directly.
    /// </summary>
    /// <param name="state">State pointer from src_new.</param>
    /// <param name="newRatio">New conversion ratio.</param>
    /// <returns>0 on success, or error code.</returns>
    [DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "src_set_ratio")]
    public static extern int SetRatio(IntPtr state, double newRatio);

    /// <summary>
    /// Gets an error string for an error code.
    /// </summary>
    /// <param name="error">Error code from a libsamplerate function.</param>
    /// <returns>Pointer to static error string.</returns>
    [DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "src_strerror")]
    public static extern IntPtr StrError(int error);

    /// <summary>
    /// Returns true if the given converter type supports variable-rate conversion.
    /// Note: ZeroOrderHold does NOT support variable ratio.
    /// </summary>
    /// <param name="converterType">Converter type constant.</param>
    /// <returns>Non-zero if variable ratio is supported.</returns>
    [DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "src_is_valid_ratio")]
    public static extern int IsValidRatio(double ratio);

    /// <summary>
    /// Gets the name of a converter type.
    /// </summary>
    /// <param name="converterType">Converter type constant.</param>
    /// <returns>Pointer to static name string.</returns>
    [DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "src_get_name")]
    public static extern IntPtr GetName(int converterType);

    /// <summary>
    /// Gets the description of a converter type.
    /// </summary>
    /// <param name="converterType">Converter type constant.</param>
    /// <returns>Pointer to static description string.</returns>
    [DllImport(LibName, CallingConvention = CallingConvention.Cdecl, EntryPoint = "src_get_description")]
    public static extern IntPtr GetDescription(int converterType);

    /// <summary>
    /// Gets the error string for an error code as a managed string.
    /// </summary>
    public static string GetErrorString(int error)
    {
        var ptr = StrError(error);
        return ptr != IntPtr.Zero ? Marshal.PtrToStringAnsi(ptr) ?? $"Unknown error {error}" : $"Unknown error {error}";
    }

    /// <summary>
    /// Gets the name of a converter type as a managed string.
    /// </summary>
    public static string GetConverterName(int converterType)
    {
        var ptr = GetName(converterType);
        return ptr != IntPtr.Zero ? Marshal.PtrToStringAnsi(ptr) ?? "Unknown" : "Unknown";
    }
}
